{
  "comments": [
    {
      "key": {
        "uuid": "a0855025_582d1cb9",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 168,
      "author": {
        "id": 1014807
      },
      "writtenOn": "2017-11-01T06:37:17Z",
      "side": 1,
      "message": "BTW, in the long run, I think it will be necessary to decouple the reader and the IR, i.e. there should be another data structure containing the loaded data and the reader actually load data into such structure.\n\nAnyway, this is beyond the scope of this CL.",
      "range": {
        "startLine": 168,
        "startChar": 9,
        "endLine": 168,
        "endChar": 27
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "84b57263_690e5355",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 168,
      "author": {
        "id": 1014807
      },
      "writtenOn": "2017-11-01T06:47:11Z",
      "side": 1,
      "message": "Or alternatively, you can refine the implementation of ReadDump() so that we can load multiple files with one local_reader (ReadDump() should accumulate the new input and should not discard the old input).",
      "parentUuid": "a0855025_582d1cb9",
      "range": {
        "startLine": 168,
        "startChar": 9,
        "endLine": 168,
        "endChar": 27
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "866ce63b_131abbff",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 168,
      "author": {
        "id": 1121338
      },
      "writtenOn": "2017-11-01T17:30:04Z",
      "side": 1,
      "message": "I think this is a better way to go. Decoupling the reader and the IR seems unnecessary.",
      "parentUuid": "84b57263_690e5355",
      "range": {
        "startLine": 168,
        "startChar": 9,
        "endLine": 168,
        "endChar": 27
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "86345cc8_630f0550",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 174,
      "author": {
        "id": 1014807
      },
      "writtenOn": "2017-11-01T06:34:29Z",
      "side": 1,
      "message": "std::lock_guard is sufficient",
      "range": {
        "startLine": 174,
        "startChar": 7,
        "endLine": 174,
        "endChar": 18
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d21eb4bc_cb788c0b",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1014807
      },
      "writtenOn": "2017-11-02T05:51:53Z",
      "side": 1,
      "message": "Even when using static balancing schedule, this calculation is not ideal.  For example, if max_threads is 4, number of files is 100, SOURCES_PER_THREAD is 5, then the distribution will be (5, 5, 5, 85), which is quite imbalance.\n\nPlease also compare the performance with:\n\n    std::size_t num_files_per_thread \u003d dump_files_.size() / num_threads;\n    std::size_t num_remainders \u003d  dump_files_.size() % num_threads;\n    std::size_t start \u003d 0;\n    for (std::size_t i \u003d 0; i \u003c num_threads; ++i) {\n      std::size_t end \u003d start + num_files_per_thread + (i \u003c num_remainders);\n      threads.emplace_back(DeDuplicateAbiElementsThread, greader.get(), dump_files_, start, end);\n      start \u003d end;\n    }",
      "range": {
        "startLine": 207,
        "startChar": 0,
        "endLine": 210,
        "endChar": 48
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf3521fd_c7674337",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1121338
      },
      "writtenOn": "2017-11-02T05:56:21Z",
      "side": 1,
      "message": "Yep, I got that. This is definitely not right or even close to optimal. Like i\u0027ve mentioned in the comments below, with static distribution we are definitely not going to have a statically defined sources_per_thread.",
      "parentUuid": "d21eb4bc_cb788c0b",
      "range": {
        "startLine": 207,
        "startChar": 0,
        "endLine": 210,
        "endChar": 48
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "60b61545_a49a74ec",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 220,
      "author": {
        "id": 1014807
      },
      "writtenOn": "2017-11-01T06:34:29Z",
      "side": 1,
      "message": "I don\u0027t like the algorithm here for 2 reasons:\n\n1. The code distribute workload by designating files to threads.  This may be sub-optimal if the sizes of files are unbalanced.\n\n2. There is a static variable in DeDuplicateAbiElementsThread\n\n----\n\nHere is my suggestion:\n\n    static void DeDuplicateAbiElementsThread(\n        std::mutex *reader_lock, abi_util::TextFormatToIRReader *reader,\n        std::atomic\u003cstd::size_t\u003e *cnt, const std::vector\u003cstd::string\u003e \u0026dump_files) {\n\n      static const char text_format[] \u003d \"protobuf\";\n\n      std::unique_ptr\u003cabi_util::TextFormatToIRReader\u003e local_reader \u003d\n          abi_util::TextFormatToIRReader::CreateTextFormatToIRReader(\n              text_format, \"\");\n\n      const std::size_t num_dump_files \u003d dump_files.size();\n      while (true) {\n        std::size_t i \u003d cnt-\u003efetch_add(1);\n        if (i \u003e\u003d num_dump_files) {\n          break;\n        }\n\n        std::unique_ptr\u003cabi_util::TextFormatToIRReader\u003e file_reader \u003d\n            abi_util::TextFormatToIRReader::CreateTextFormatToIRReader(\n                text_format, dump_files[i]);\n\n        assert(reader !\u003d nullptr);\n        if (!reader-\u003eReadDump()) {\n          llvm::errs() \u003c\u003c \"ReadDump failed\\n\";\n          ::exit(1);\n        }\n\n        local_reader-\u003eMerge(*file_reader);\n      }\n\n      std::lock_guard\u003cstd::mutex\u003e lock(*reader_lock);\n      reader-\u003eMerge(*local_reader);\n    }\n\n\n    bool HeaderAbiLinker::LinkAndDump() {\n      // ... skipped ...\n\n      std::atomic\u003cstd::size_t\u003e cnt(0);\n      std::mutex reader_lock;\n      std::unique_ptr\u003cabi_util::TextFormatToIRReader\u003e reader \u003d\n          abi_util::TextFormatToIRReader::CreateTextFormatToIRReader(\n              \"protobuf\", \"\");\n\n      std::size_t max_threads \u003d std::thread::hardware_concurrency();\n      std::vector\u003cstd::thread\u003e threads;\n      for (std::size_t i \u003d 1; i \u003c max_threads; ++i) {\n        threads.emplace_back(DeDuplicateAbiElementsThread, \u0026reader_lock,\n                             reader.get(), \u0026cnt, dump_files_);\n      }\n      DeDuplicateAbiElementsThread(\u0026reader_lock, reader.get(), \u0026cnt, dump_files_);\n      for (std::thread \u0026thread : threads) {\n        thread.join();\n      }\n\n      // ... skipped ...\n    }",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f3f2bc2_80fcdc61",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 220,
      "author": {
        "id": 1121338
      },
      "writtenOn": "2017-11-01T17:30:04Z",
      "side": 1,
      "message": "Yes, you\u0027re right about the fact that there could be unbalanced loads. That definitely should be fixed (we probably want don\u0027t want to have a #define for the number of source files / thread). I see a couple of problems with your suggestion though:\n\n1) You\u0027re spawning off max_threads regardless of the number of source files which is probably not desirable. We should probably cap this at number of dump files being processed.\n\n2) The idea of dynamically assigning threads is a better way to go, however, I think we might be missing out on the fact that the results of these threads need to interact. Consider the scenario where we have 48 threads and 48 source files. It\u0027s possible that the assignment leads to each thread getting one source file each. This gets reduced to the case where everything is serialized. I tried out your code on libbcinfo.so(so that we compare it with the results in the commit message, near about 150 sources files) and got the following performance results (I capped the number of threads to be std::min(max_threads, dump_files.size()))\n:\nreal\t0m13.668s\nuser\t0m51.604s\nsys\t0m14.352s\n\nIn this case we can see that distributing the sources performed better. But yeah there are definitely going to be cases where dynamic distribution is going to be better (in the current algorithm we could very easily have threads which process very big dump files, and other threads finished well before them and now we\u0027re waiting on the join). We probably need to implement an algorithm where both these problems are somewhat solved.\n\n3) Do we need the second DeDuplicateAbiElements  at all?",
      "parentUuid": "60b61545_a49a74ec",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "780002ae_16dfe015",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 220,
      "author": {
        "id": 1121338
      },
      "writtenOn": "2017-11-01T17:52:09Z",
      "side": 1,
      "message": "Regarding 2) we should probably have multiple stages of linking threads so that we don\u0027t serialize the deduplication that does not need to be serialized.",
      "parentUuid": "9f3f2bc2_80fcdc61",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4751bb7a_94fb656f",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 220,
      "author": {
        "id": 1014807
      },
      "writtenOn": "2017-11-02T05:34:07Z",
      "side": 1,
      "message": "3) Notice that I started from 1 and using main thread as zero, i.e. if there are 48 cores, then I will spawn 47 threads and also run DeDuplicateAbiElements() in main thread.",
      "parentUuid": "9f3f2bc2_80fcdc61",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f8adbd0_08a08f41",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 220,
      "author": {
        "id": 1014807
      },
      "writtenOn": "2017-11-02T05:38:40Z",
      "side": 1,
      "message": "BTW, there was an error in my version.  The `reader-\u003eReadDump()` and `assert(reader !\u003d nullptr)` after file_reader should be replaced by file reader.  Did you fix it as well?",
      "parentUuid": "4751bb7a_94fb656f",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37f2f5af_329b932b",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 220,
      "author": {
        "id": 1014807
      },
      "writtenOn": "2017-11-02T05:38:40Z",
      "side": 1,
      "message": "Regarding to performance, may you tweek the fetch_add with 5 and tweak the code accordingly?  I am interested in the performance.",
      "parentUuid": "9f3f2bc2_80fcdc61",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09f6d3ac_05f42063",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 220,
      "author": {
        "id": 1121338
      },
      "writtenOn": "2017-11-02T05:56:21Z",
      "side": 1,
      "message": "Yes, with this, since there\u0027s better distribution, along with lesser unbalanced load distribution, I expect better performance. I\u0027ll try this tomorrow. I\u0027ll also see if its easy enough implementing the multiple stages algorithm.",
      "parentUuid": "37f2f5af_329b932b",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32dd003c_e0f2b3be",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 220,
      "author": {
        "id": 1121338
      },
      "writtenOn": "2017-11-02T05:56:21Z",
      "side": 1,
      "message": "Yep, I did. That would be incorrect since its a shared resource and we\u0027re doing ReadDump() on it without using a lock.",
      "parentUuid": "9f8adbd0_08a08f41",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85b1207a_08a79338",
        "filename": "vndk/tools/header-checker/header-abi-linker/src/header_abi_linker.cpp",
        "patchSetId": 1
      },
      "lineNbr": 220,
      "author": {
        "id": 1121338
      },
      "writtenOn": "2017-11-02T05:56:21Z",
      "side": 1,
      "message": "Aah, I missed that.",
      "parentUuid": "4751bb7a_94fb656f",
      "range": {
        "startLine": 200,
        "startChar": 0,
        "endLine": 220,
        "endChar": 3
      },
      "revId": "81307ccfabf7ef253a279754bff92e8a9f61c1e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}